/*!
 * @package @coolgk/mongo
 * @version 1.0.15
 * @link https://coolgk.github.io/mongodb-orm.html
 * @license MIT
 * @author Daniel Gong <daniel.k.gong@gmail.com>
 */

"use strict";
/*!
 *  Copyright (c) 2017 Daniel Gong <daniel.k.gong@gmail.com>. All rights reserved.
 *  Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const mongodb_1 = require("mongodb");
const array_1 = require("@coolgk/array");
var GeneratedField;
(function (GeneratedField) {
    GeneratedField["DATE_MODIFIED"] = "_dateModified";
})(GeneratedField = exports.GeneratedField || (exports.GeneratedField = {}));
var DataType;
(function (DataType) {
    DataType["STRING"] = "string";
    DataType["BOOLEAN"] = "bool";
    DataType["DATE"] = "date";
    DataType["NUMBER"] = "number";
    DataType["DOCUMENT"] = "document";
    DataType["ENUM"] = "enum";
    DataType["OBJECTID"] = "objectId";
})(DataType = exports.DataType || (exports.DataType = {}));
class MongoError extends Error {
}
exports.MongoError = MongoError;
class SchemaError extends Error {
}
exports.SchemaError = SchemaError;
class Mongo {
    constructor(options) {
        this._schema = {};
        this._db = options.db;
        this._schema = this.constructor.getSchema();
        this._collection = this._db.collection(this.constructor.getCollectionName());
    }
    static getCollectionName() {
        throw new MongoError('Undefined static method "getCollectionName"');
    }
    static getSchema() {
        throw new MongoError('Undefined static method "getSchema"');
    }
    getObjectID(id) {
        return mongodb_1.ObjectID.isValid(String(id)) ? new mongodb_1.ObjectID(id) : undefined;
    }
    getObjectId(id) {
        return this.getObjectID(id);
    }
    getDb() {
        return this._db;
    }
    getCollection() {
        return this._collection;
    }
    setDbValidationSchema() {
        return __awaiter(this, void 0, void 0, function* () {
            const collections = yield this._db.collections();
            const collectionName = this.constructor.getCollectionName();
            if (collections.find((collection) => collection.collectionName === collectionName)) {
                return this._db.command({
                    collMod: collectionName,
                    validator: {
                        $jsonSchema: this._getJsonSchema(this._schema)
                    },
                    validationLevel: 'strict',
                    validationAction: 'error'
                });
            }
            return this._db.createCollection(collectionName, {
                validator: {
                    $jsonSchema: this._getJsonSchema(this._schema)
                },
                validationLevel: 'strict',
                validationAction: 'error'
            });
        });
    }
    insertOne(data, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._transform(array_1.toArray(data), { type: DataType.DOCUMENT, schema: this._schema, array: true });
            return this._collection.insertOne(data, options);
        });
    }
    insertMany(data, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._transform(array_1.toArray(data), { type: DataType.DOCUMENT, schema: this._schema, array: true });
            return this._collection.insertMany(data, options);
        });
    }
    updateOne(data, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!data._id) {
                throw new MongoError('Update Failed: missing "_id" in document');
            }
            yield this._transform(array_1.toArray(data), { type: DataType.DOCUMENT, schema: this._schema, array: true }, false);
            const queries = yield this._getUpdateQuery(data, { type: DataType.DOCUMENT, schema: this._schema });
            const results = {
                raw: {}
            };
            const dataBeforeUpdate = options.revertOnError ? yield this._collection.findOne({ _id: data._id }) : false;
            const errors = {};
            for (const action of ['$set', '$push', '$pull']) {
                if (!queries[action]) {
                    continue;
                }
                results.raw[action] = (yield this._collection.findOneAndUpdate({
                    _id: data._id
                }, {
                    [action]: queries[action].values
                }, Object.assign({}, options, { arrayFilters: queries[action].arrayFilters })).catch((error) => {
                    errors[action] = error;
                })) || {};
                if (options.returnOriginal) {
                    if (!results.value) {
                        results.value = results.raw[action].value;
                    }
                }
                else {
                    results.value = results.raw[action].value;
                }
            }
            if (Object.keys(errors).length) {
                if (options.revertOnError) {
                    const revertResult = yield this._collection.findOneAndReplace({ _id: dataBeforeUpdate._id }, dataBeforeUpdate).catch((revertError) => {
                        errors.$revert = revertError;
                    });
                }
                const error = new MongoError('UpdateOne Error: ' + JSON.stringify(errors));
                error.data = Object.assign({}, results, { error: errors });
                throw error;
            }
            return results;
        });
    }
    find(query, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const cursor = this._collection.find(yield this._getJoinQuery(this.constructor, query, options.join), options);
            const data = options.cursor ? cursor : yield cursor.toArray();
            return options.join ? yield this.attachObjectIdData(data, options.join) : data;
        });
    }
    attachObjectIdData(data, joins) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data.constructor.name === 'Cursor') {
                return data.map((row) => __awaiter(this, void 0, void 0, function* () {
                    yield this._attachDataToReferencePointer(row, joins, {
                        type: DataType.DOCUMENT,
                        schema: this._schema
                    });
                    return row;
                }));
            }
            else {
                yield this._attachDataToReferencePointer(data, joins, {
                    type: DataType.DOCUMENT,
                    schema: this._schema,
                    array: data.constructor.name === 'Array'
                });
            }
            return data;
        });
    }
    _attachDataToReferencePointer(data, joins, dataSchema, model = this.constructor) {
        return __awaiter(this, void 0, void 0, function* () {
            joins = array_1.toArray(joins);
            const fieldPathsInJoin = joins.reduce((fieldPaths, join) => {
                return fieldPaths.concat(array_1.toArray(join.on));
            }, []);
            const objectIdInData = {};
            this._findObjectIdInData(data, dataSchema, fieldPathsInJoin, objectIdInData);
            if (Object.keys(objectIdInData).length === 0) {
                return;
            }
            for (const join of joins) {
                const fields = array_1.toArray(join.on);
                const joinModel = join.model || this._findObjectIdFieldModel(fields[0], model);
                const referencePointers = {};
                const ids = [];
                fields.forEach((field) => {
                    if (objectIdInData[field]) {
                        objectIdInData[field].forEach((referencePointer) => {
                            const id = referencePointer.parent[referencePointer.field]._id;
                            if (!referencePointers[id]) {
                                referencePointers[id] = [];
                            }
                            referencePointers[id].push(referencePointer);
                            ids.push(id);
                        });
                    }
                });
                let joinData = join.data;
                if (!joinData) {
                    const projection = join.projection;
                    if (projection && projection._id === 0) {
                        delete projection._id;
                    }
                    joinData = this._db.collection(joinModel.getCollectionName()).find({
                        _id: {
                            $in: ids
                        }
                    }, { projection });
                }
                if (join.join) {
                    yield this._attachDataToReferencePointer(yield joinData.map((row) => {
                        if (referencePointers[row._id]) {
                            referencePointers[row._id].forEach((referencePointer) => {
                                referencePointer.parent[referencePointer.field] = row;
                            });
                        }
                        return row;
                    }).toArray(), join.join, {
                        type: DataType.DOCUMENT,
                        schema: joinModel.getSchema(),
                        array: true
                    }, joinModel);
                }
                else {
                    yield new Promise((resolve) => {
                        joinData.forEach((row) => {
                            if (referencePointers[row._id]) {
                                referencePointers[row._id].forEach((referencePointer) => {
                                    referencePointer.parent[referencePointer.field] = row;
                                });
                            }
                        }, () => resolve());
                    });
                }
            }
        });
    }
    _findObjectIdInData(data, dataSchema, fieldPathsInJoin, objectIdInData, referencePointer) {
        if (dataSchema) {
            if (dataSchema.array) {
                array_1.toArray(data).forEach((row, index) => {
                    this._findObjectIdInData(row, Object.assign({}, dataSchema, { array: false }), fieldPathsInJoin, objectIdInData, {
                        parent: data,
                        field: index,
                        path: referencePointer && referencePointer.path || []
                    });
                });
            }
            else {
                switch (dataSchema.type) {
                    case DataType.DOCUMENT:
                        if (!dataSchema.schema) {
                            throw new SchemaError(`Undefined "schema" property on "${dataSchema.type}" type in ${JSON.stringify(dataSchema)}`);
                        }
                        for (const field in data) {
                            this._findObjectIdInData(data[field], dataSchema.schema[field], fieldPathsInJoin, objectIdInData, {
                                parent: data,
                                field,
                                path: array_1.toArray(referencePointer && referencePointer.path).concat(field)
                            });
                        }
                        break;
                    case DataType.OBJECTID:
                        if (data && referencePointer) {
                            if (!dataSchema.model) {
                                throw new SchemaError(`Undefined "model" property on "${dataSchema.type}" type in ${JSON.stringify(dataSchema)}`);
                            }
                            const fieldPath = referencePointer.path.join('.');
                            if (fieldPathsInJoin.includes(fieldPath)) {
                                const collection = dataSchema.model.getCollectionName();
                                if (!objectIdInData[fieldPath]) {
                                    objectIdInData[fieldPath] = [];
                                }
                                referencePointer.parent[referencePointer.field] = {
                                    _id: data.constructor.name === 'ObjectID' ? data : data.oid
                                };
                                objectIdInData[fieldPath].push(referencePointer);
                            }
                        }
                        break;
                }
            }
        }
    }
    _getJoinQuery(model, query = {}, joins) {
        return __awaiter(this, void 0, void 0, function* () {
            if (query && typeof (query._id) === 'string') {
                query._id = this.getObjectID(query._id);
            }
            if (joins) {
                const joinQuery = {
                    $and: []
                };
                for (const join of array_1.toArray(joins)) {
                    const fields = array_1.toArray(join.on);
                    join.model = this._findObjectIdFieldModel(fields[0], model);
                    const filters = yield this._getJoinQuery(join.model, join.filters, join.join);
                    if (Object.keys(filters).length) {
                        const projection = join.projection || {};
                        if (projection._id === 0) {
                            delete projection._id;
                        }
                        const cursor = this._db.collection(join.model.getCollectionName()).find(filters, {
                            projection
                        });
                        const ids = (yield cursor.toArray()).map((row) => row._id);
                        fields.forEach((field) => {
                            joinQuery.$and.push({
                                [field]: {
                                    $in: ids
                                }
                            });
                        });
                        cursor.rewind();
                        join.data = cursor;
                    }
                }
                if (joinQuery.$and.length) {
                    if (query && Object.keys(query).length) {
                        joinQuery.$and.push(query);
                    }
                    return joinQuery;
                }
            }
            return query;
        });
    }
    _findObjectIdFieldModel(fieldPath, model) {
        const fields = fieldPath.split('.');
        let schema = model.getSchema();
        while (fields.length > 1) {
            const field = fields.shift();
            if (schema[field].schema) {
                schema = schema[field].schema;
            }
            else {
                throw new SchemaError('\nUndefined "model" property or Invalid Object ID field in join statement.\n'
                    + `On: "${fieldPath}"\n`
                    + `Collection: ${model.getCollectionName()}\n`
                    + `Schema: ${JSON.stringify(model.getSchema())}\n`);
            }
        }
        const objectIdField = fields.shift();
        const fieldModel = objectIdField && schema && schema[objectIdField] && schema[objectIdField].model;
        if (fieldModel) {
            return fieldModel;
        }
        throw new SchemaError('\nUndefined "model" property or Invalid Object ID field in join statement.\n'
            + `On: "${fieldPath}"\n`
            + `Collection: ${model.getCollectionName()}\n`
            + `Schema: ${JSON.stringify(model.getSchema())}\n`);
    }
    _getJsonSchema(schema) {
        const jsonSchema = {
            bsonType: 'object',
            additionalProperties: false
        };
        const properties = {
            _id: {
                bsonType: 'objectId'
            },
            [GeneratedField.DATE_MODIFIED]: {
                bsonType: 'date'
            }
        };
        const required = [];
        for (const field in schema) {
            let propertyJsonSchema = {};
            schema[field].maxLength && (propertyJsonSchema.maxLength = schema[field].maxLength);
            schema[field].minLength && (propertyJsonSchema.minLength = schema[field].minLength);
            schema[field].minimum && (propertyJsonSchema.minimum = schema[field].minimum);
            schema[field].maximum && (propertyJsonSchema.maximum = schema[field].maximum);
            schema[field].pattern && (propertyJsonSchema.pattern = schema[field].pattern);
            switch (schema[field].type) {
                case DataType.NUMBER:
                    propertyJsonSchema.bsonType = ['double', 'int', 'long', 'decimal'];
                    break;
                case DataType.ENUM:
                    propertyJsonSchema.enum = schema[field].enum;
                    break;
                case DataType.DOCUMENT:
                    propertyJsonSchema = this._getJsonSchema(schema[field].schema);
                    break;
                default:
                    propertyJsonSchema.bsonType = schema[field].type;
                    break;
            }
            if (schema[field].array) {
                properties[field] = {
                    bsonType: 'array',
                    items: propertyJsonSchema
                };
                schema[field].maxItems && (properties[field].maxItems = schema[field].maxItems);
                schema[field].minItems && (properties[field].minItems = schema[field].minItems);
                schema[field].uniqueItems && (properties[field].uniqueItems = schema[field].uniqueItems);
            }
            else {
                properties[field] = propertyJsonSchema;
            }
            if (schema[field].required) {
                required.push(field);
            }
            else {
                if (properties[field].bsonType) {
                    properties[field].bsonType = [...array_1.toArray(properties[field].bsonType), 'null'];
                }
                if (properties[field].enum) {
                    properties[field].enum = [...array_1.toArray(properties[field].enum), null];
                }
            }
        }
        jsonSchema.properties = properties;
        if (required.length) {
            jsonSchema.required = required;
        }
        return jsonSchema;
    }
    _transform(data, dataSchema, insert = true, referencePointer) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!dataSchema) {
                return;
            }
            if (data === undefined) {
                if (insert && dataSchema.default !== undefined && referencePointer) {
                    referencePointer.parent[referencePointer.field] = dataSchema.default;
                    data = dataSchema.default;
                }
                else {
                    return;
                }
            }
            if (dataSchema.array) {
                data = array_1.toArray(data);
                for (let index = data.length - 1; index >= 0; index--) {
                    if (dataSchema.type === DataType.DOCUMENT) {
                        data[index][GeneratedField.DATE_MODIFIED] = new Date();
                        if (data[index]._id) {
                            data[index]._id = this.getObjectID(data[index]._id) || data[index]._id;
                        }
                        else if (insert) {
                            data[index]._id = new mongodb_1.ObjectID();
                        }
                    }
                    yield this._transform(data[index], Object.assign({}, dataSchema, { array: false }), insert, { parent: data, field: index });
                }
            }
            else {
                if (dataSchema.setter) {
                    data = yield dataSchema.setter(data, referencePointer ? referencePointer.parent : data);
                    this._setTransformedValue(data, referencePointer);
                }
                switch (dataSchema.type) {
                    case DataType.DOCUMENT:
                        if (!dataSchema.schema) {
                            throw new SchemaError(`Undefined "schema" property on "${dataSchema.type}" type in ${JSON.stringify(dataSchema)}`);
                        }
                        if (data instanceof Object) {
                            for (const field in dataSchema.schema) {
                                yield this._transform(data[field], dataSchema.schema[field], insert, { parent: data, field });
                            }
                        }
                        break;
                    case DataType.NUMBER:
                        if (!isNaN(data)) {
                            this._setTransformedValue(+data, referencePointer);
                        }
                        break;
                    case DataType.DATE:
                        const date = new Date(data);
                        if (!isNaN(date.getTime())) {
                            this._setTransformedValue(date, referencePointer);
                        }
                        break;
                    case DataType.BOOLEAN:
                        this._setTransformedValue((data === 'false' || data === '0') ? false : !!data, referencePointer);
                        break;
                    case DataType.OBJECTID:
                        this._setTransformedValue(this.getObjectID(data) || data, referencePointer);
                        break;
                }
            }
        });
    }
    _setTransformedValue(newValue, referencePointer) {
        if (referencePointer) {
            referencePointer.parent[referencePointer.field] = newValue;
        }
    }
    _getUpdateQuery(data, dataSchema, parent = { arrayFilters: [], path: [] }, queries = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!dataSchema) {
                return queries;
            }
            if (dataSchema.array) {
                if (data.$replace) {
                    const dataToSet = array_1.toArray(data.$replace);
                    yield this._transform(dataToSet, dataSchema);
                    yield this._setUpdateQuery(queries, parent, '$set', dataToSet);
                    return queries;
                }
                if (data.$delete) {
                    yield this._setUpdateQuery(queries, parent, '$pull', dataSchema.type === DataType.DOCUMENT ? {
                        _id: {
                            $in: array_1.toArray(data.$delete).map((id) => this.getObjectID(id))
                        }
                    } : {
                        $in: array_1.toArray(data.$delete)
                    });
                    if (!data.$update) {
                        return queries;
                    }
                }
                if (data.$update) {
                    yield this._transform(dataSchema.type === DataType.DOCUMENT ? array_1.toArray(data.$update).filter((row) => row._id) : array_1.toArray(data.$update), dataSchema);
                }
                data = array_1.toArray(data.$update || data);
                if (dataSchema.type === DataType.DOCUMENT) {
                    const dataToInsert = [];
                    for (let index = data.length - 1; index >= 0; index--) {
                        if (data[index]._id) {
                            yield this._getUpdateQuery(data[index], Object.assign({}, dataSchema, { array: false }), {
                                arrayFilters: parent.arrayFilters.concat({
                                    [`i${data[index]._id}._id`]: this.getObjectID(data[index]._id)
                                }),
                                path: parent.path.concat(`$[i${data[index]._id}]`)
                            }, queries);
                        }
                        else {
                            yield this._transform([data[index]], dataSchema);
                            dataToInsert.push(data[index]);
                        }
                    }
                    if (dataToInsert.length) {
                        yield this._setUpdateQuery(queries, parent, '$push', {
                            $each: dataToInsert
                        });
                    }
                }
                else {
                    yield this._setUpdateQuery(queries, parent, '$push', {
                        $each: data
                    });
                }
            }
            else {
                switch (dataSchema.type) {
                    case DataType.DOCUMENT:
                        if (!dataSchema.schema) {
                            throw new SchemaError(`Undefined "schema" property on "${dataSchema.type}" type in ${JSON.stringify(dataSchema)}`);
                        }
                        if (data instanceof Object) {
                            for (const field in data) {
                                yield this._getUpdateQuery(data[field], field === GeneratedField.DATE_MODIFIED ? {
                                    type: DataType.DATE
                                } : dataSchema.schema[field], {
                                    arrayFilters: parent.arrayFilters,
                                    path: parent.path.concat(field)
                                }, queries);
                            }
                        }
                        break;
                    default:
                        yield this._setUpdateQuery(queries, parent, '$set', data);
                        break;
                }
            }
            return queries;
        });
    }
    _setUpdateQuery(queries, parent, action, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const parentPath = parent.path.join('.');
            if (!queries[action]) {
                queries[action] = {
                    values: {},
                    arrayFilters: []
                };
            }
            Object.assign(queries[action].values, {
                [parentPath]: data
            });
            const currentFiltersById = {};
            queries[action].arrayFilters.forEach((filter) => {
                for (const id in filter) {
                    currentFiltersById[id.substr(1)] = 1;
                }
            });
            queries[action].arrayFilters.push(...parent.arrayFilters.filter((filter) => {
                for (const id in filter) {
                    if (currentFiltersById[id.substr(1)]) {
                        return false;
                    }
                }
                return true;
            }));
        });
    }
}
exports.Mongo = Mongo;
exports.default = Mongo;
